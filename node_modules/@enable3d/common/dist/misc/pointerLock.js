class PointerLock {
    constructor(_element, autoLock = true) {
        this._element = _element;
        this._isRunning = false;
        if (autoLock)
            this.request();
    }
    isLocked() {
        return !!document.pointerLockElement;
    }
    exit() {
        this._isRunning = false;
        document.exitPointerLock();
        this.removeListeners();
    }
    removeListeners() {
        document.removeEventListener('pointerlockchange', () => this.pointerLockChangeHandler());
        this._element.removeEventListener('pointerdown', () => this.pointerDownHandlerHandler());
    }
    pointerLockChangeHandler() {
        if (!this._isRunning)
            return;
        this._request();
    }
    pointerDownHandlerHandler() {
        if (!this._isRunning)
            return;
        this._element.requestPointerLock();
    }
    request() {
        this._isRunning = true;
        this._request();
    }
    _request() {
        // listen to pointer lock change events
        document.addEventListener('pointerlockchange', () => this.pointerLockChangeHandler(), {
            once: true
        });
        // return if pointer is already locked
        if (document.pointerLockElement)
            return;
        // listen for pointerdown event
        this._element.addEventListener('pointerdown', () => this.pointerDownHandlerHandler(), { once: true });
    }
}
export { PointerLock };
//# sourceMappingURL=pointerLock.js.map