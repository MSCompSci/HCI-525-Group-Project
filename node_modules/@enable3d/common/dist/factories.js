/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
import { DoubleSide, Line, LineBasicMaterial, MeshBasicMaterial, MeshLambertMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, Points, PointsMaterial, MathUtils as THREE_Math, BoxGeometry, ExtrudeGeometry, PlaneGeometry, SphereGeometry, CylinderGeometry, ConeGeometry, TorusGeometry } from 'three';
import { ExtendedMesh } from './extendedMesh';
import { logger } from './logger';
import DefaultMaterial from './defaultMaterial';
export default class Factories {
    constructor(scene) {
        this.scene = scene;
        this.isHeadless = scene === 'headless' ? true : false;
        this.defaultMaterial = new DefaultMaterial();
    }
    get make() {
        return {
            plane: (planeConfig = {}, materialConfig = {}) => this.makePlane(planeConfig, materialConfig),
            box: (boxConfig = {}, materialConfig = {}) => this.makeBox(boxConfig, materialConfig),
            sphere: (sphereConfig = {}, materialConfig = {}) => this.makeSphere(sphereConfig, materialConfig),
            cylinder: (cylinderConfig = {}, materialConfig = {}) => this.makeCylinder(cylinderConfig, materialConfig),
            cone: (coneConfig = {}, materialConfig = {}) => this.makeCone(coneConfig, materialConfig),
            torus: (torusConfig = {}, materialConfig = {}) => this.makeTorus(torusConfig, materialConfig),
            extrude: (extrudeConfig, materialConfig = {}) => this.makeExtrude(extrudeConfig, materialConfig)
        };
    }
    get add() {
        return {
            // effectComposer: () => this.addEffectComposer(),
            mesh: (mesh) => this.addMesh(mesh),
            // group: (...children) => this.addGroup(children),
            existing: (object) => this.addExisting(object),
            //  Geometry
            plane: (planeConfig = {}, materialConfig = {}) => this.addPlane(planeConfig, materialConfig),
            box: (boxConfig = {}, materialConfig = {}) => this.addBox(boxConfig, materialConfig),
            ground: (groundConfig, materialConfig = {}) => this.addGround(groundConfig, materialConfig),
            //...
            sphere: (sphereConfig = {}, materialConfig = {}) => this.addSphere(sphereConfig, materialConfig),
            cylinder: (cylinderConfig = {}, materialConfig = {}) => this.addCylinder(cylinderConfig, materialConfig),
            cone: (coneConfig = {}, materialConfig = {}) => this.addCone(coneConfig, materialConfig),
            torus: (torusConfig = {}, materialConfig = {}) => this.addTorus(torusConfig, materialConfig),
            extrude: (extrudeConfig, materialConfig = {}) => this.addExtrude(extrudeConfig, materialConfig),
            //...
            material: (materialConfig = {}) => this.addMaterial(materialConfig)
        };
    }
    addExisting(...object) {
        if (this.scene === 'headless')
            return;
        this.scene.add(...object);
    }
    addMesh(mesh) {
        if (Array.isArray(mesh)) {
            for (let i = 0; i < mesh.length; i++) {
                this.addExisting(mesh[i]);
            }
        }
        else {
            this.addExisting(mesh);
        }
        return this;
    }
    createMesh(geometry, material, position) {
        const { x = 0, y = 0, z = 0 } = position;
        let obj;
        switch (!Array.isArray(material) && material.type) {
            case 'LineBasicMaterial':
                obj = new Line(geometry, material);
                break;
            case 'PointsMaterial':
                obj = new Points(geometry, material);
                break;
            default:
                obj = new ExtendedMesh(geometry, material);
                break;
        }
        obj.position.set(x, y, z);
        obj.castShadow = obj.receiveShadow = true;
        return obj;
    }
    makeExtrude(extrudeConfig, materialConfig) {
        const { x, y, z, name, shape, autoCenter = true, breakable = false, ...rest } = extrudeConfig;
        // @ts-expect-error ExtrudeGeometryOptions interface is missing since three.js r121.
        const { depth = 1, bevelEnabled = false } = rest;
        const geometry = new ExtrudeGeometry(shape, { depth, bevelEnabled, ...rest });
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        // auto adjust the center for custom shapes
        if (autoCenter)
            mesh.geometry.center();
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'extrude';
        return mesh;
    }
    addExtrude(extrudeConfig, materialConfig = {}) {
        const obj = this.makeExtrude(extrudeConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    makePlane(planeConfig, materialConfig) {
        const { x, y, z, name, breakable = false, ...rest } = planeConfig;
        const geometry = new PlaneGeometry(rest.width || 1, rest.height || 1, rest.widthSegments || 1, rest.heightSegments || 1);
        const material = this.addMaterial(materialConfig);
        material.side = DoubleSide;
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'plane';
        return mesh;
    }
    addPlane(planeConfig, materialConfig) {
        const obj = this.makePlane(planeConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    makeSphere(sphereConfig, materialConfig) {
        const { x, y, z, name, breakable = false, ...rest } = sphereConfig;
        const geometry = new SphereGeometry(rest.radius || 1, rest.widthSegments || 16, rest.heightSegments || 12, rest.phiStart || undefined, rest.phiLength || undefined, rest.thetaStart || undefined, rest.thetaLength || undefined);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'sphere';
        return mesh;
    }
    addSphere(sphereConfig = {}, materialConfig = {}) {
        const obj = this.makeSphere(sphereConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    makeBox(boxConfig, materialConfig) {
        const { x, y, z, name, breakable = false, ...rest } = boxConfig;
        const geometry = new BoxGeometry(rest.width || 1, rest.height || 1, rest.depth || 1, rest.widthSegments || undefined, rest.heightSegments || undefined, rest.depthSegments || undefined);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'box';
        return mesh;
    }
    addBox(boxConfig = {}, materialConfig = {}) {
        const obj = this.makeBox(boxConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    addGround(groundConfig, materialConfig = {}) {
        const obj = this.makeBox(groundConfig, materialConfig);
        obj.rotateX(THREE_Math.degToRad(90));
        this.addExisting(obj);
        return obj;
    }
    makeCylinder(cylinderConfig = {}, materialConfig = {}) {
        const { x, y, z, name, breakable = false, ...rest } = cylinderConfig;
        const geometry = new CylinderGeometry(rest.radiusTop || 1, rest.radiusBottom || 1, rest.height || 1, rest.radiusSegments || undefined, rest.heightSegments || undefined, rest.openEnded || undefined, rest.thetaStart || undefined, rest.thetaLength || undefined);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'cylinder';
        return mesh;
    }
    addCylinder(cylinderConfig = {}, materialConfig = {}) {
        const obj = this.makeCylinder(cylinderConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    makeCone(coneConfig = {}, materialConfig = {}) {
        const { x, y, z, name, breakable = false, ...rest } = coneConfig;
        const geometry = new ConeGeometry(rest.radius || 1, rest.height || 1, rest.radiusSegments || 8, rest.heightSegments || 1, rest.openEnded || false, rest.thetaStart || 0, rest.thetaLength || 2 * Math.PI);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'cone';
        return mesh;
    }
    addCone(coneConfig = {}, materialConfig = {}) {
        const obj = this.makeCone(coneConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    // https://threejs.org/docs/index.html#api/en/geometries/TorusBufferGeometry
    makeTorus(torusConfig = {}, materialConfig = {}) {
        const { x, y, z, name, breakable = false, ...rest } = torusConfig;
        const geometry = new TorusGeometry(rest.radius || undefined, rest.tube || undefined, rest.radialSegments || undefined, rest.tubularSegments || undefined, rest.arc || undefined);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'torus';
        return mesh;
    }
    addTorus(torusConfig = {}, materialConfig = {}) {
        const obj = this.makeTorus(torusConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    addMaterial(materialConfig = {}) {
        const type = Object.keys(materialConfig)[0];
        let material;
        // if (type) {
        //   const { map } = materialConfig[type]
        //   if (typeof map === 'string') materialConfig[type].map = this.loadTexture(map)
        // }
        // always share the same material in headless mode to save memory
        if (this.scene === 'headless')
            return this.defaultMaterial.get();
        switch (type) {
            case 'basic':
                material = new MeshBasicMaterial(materialConfig.basic);
                break;
            case 'normal':
                material = new MeshNormalMaterial(materialConfig.normal);
                break;
            case 'standard':
                material = new MeshStandardMaterial(materialConfig.standard);
                break;
            case 'lambert':
                material = new MeshLambertMaterial(materialConfig.lambert);
                break;
            case 'phong':
                material = new MeshPhongMaterial(materialConfig.phong);
                break;
            case 'physical':
                if (typeof materialConfig.physical !== 'undefined') {
                    material = new MeshPhysicalMaterial(materialConfig.physical);
                }
                else {
                    logger('You need to pass parameters to the physical material. (Fallback to default material)');
                    material = this.defaultMaterial.get();
                }
                break;
            case 'toon':
                material = new MeshToonMaterial(materialConfig.toon);
                break;
            case 'line':
                material = new LineBasicMaterial(materialConfig.line);
                break;
            case 'points':
                material = new PointsMaterial(materialConfig.points);
                break;
            case 'custom':
                material = materialConfig.custom || this.defaultMaterial.get();
                break;
            default:
                material = this.defaultMaterial.get();
                break;
        }
        return material;
    }
}
//# sourceMappingURL=factories.js.map