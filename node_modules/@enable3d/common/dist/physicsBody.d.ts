/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
import { ExtendedObject3D, XYZ } from './types';
import { CollisionEvent } from './types';
declare class PhysicsBody {
    private physics;
    ammo: Ammo.btRigidBody;
    ptr: any | undefined;
    body: any | undefined;
    ignoreScale: boolean;
    isSoftBody: boolean;
    offset: {
        x: number;
        y: number;
        z: number;
    };
    name: string;
    errors: string[];
    checkCollisions: boolean;
    impact: {
        impulse: number;
        point: XYZ;
        normal: XYZ;
        name: string;
    }[];
    breakable: boolean;
    fractureImpulse: number;
    didUpdate: boolean;
    /** Skip syncing the mesh to the physics body. */
    skipUpdate: boolean;
    private _emitUpdateEvents;
    private _needUpdate;
    private tmpEuler;
    private tmpQuaternion;
    private tmpBtVector3;
    private tmpBtVector3_1;
    private tmpBtQuaternion;
    private eventEmitter;
    constructor(physics: any, ammo: Ammo.btRigidBody);
    /**
     * Don't call this manually! Do physics.destroy() instead.
     */
    destructor(): void;
    private setupEventEmitter;
    get needUpdate(): boolean;
    set needUpdate(need: boolean);
    private onUpdateEvent;
    get on(): {
        update: (updateCallback: Function) => void;
        collision: (collisionCallback: (otherObject: ExtendedObject3D, event: CollisionEvent) => void) => void;
    };
    get once(): {
        update: (updateCallback: Function) => void;
    };
    private onCollision;
    /** You have to call transform() before you can get or set the body's position or rotation. (for headless mode only) */
    transform(): void;
    /** You have to call refresh() after you set the position or rotation of the body. (for headless mode only) */
    refresh(): void;
    /** Set the rotation in radians. (for headless mode only) */
    setRotation(x: number, y: number, z: number): void;
    /** Get the rotation in radians. (for headless mode only) */
    get rotation(): {
        x: number;
        y: number;
        z: number;
    };
    /** Get the quaternion. (for headless mode only) */
    get quaternion(): {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    /** Set position. (for headless mode only) */
    setPosition(x: number, y: number, z: number): void;
    /** Get position. (for headless mode only) */
    get position(): {
        x: number;
        y: number;
        z: number;
    };
    get velocity(): {
        x: number;
        y: number;
        z: number;
    };
    get angularVelocity(): {
        x: number;
        y: number;
        z: number;
    };
    setVelocity(x: number, y: number, z: number): void;
    setVelocityX(value: number): void;
    setVelocityY(value: number): void;
    setVelocityZ(value: number): void;
    setAngularVelocity(x: number, y: number, z: number): void;
    setAngularVelocityX(value: number): void;
    setAngularVelocityY(value: number): void;
    setAngularVelocityZ(value: number): void;
    applyForce(x: number, y: number, z: number): void;
    applyForceX(value: number): void;
    applyForceY(value: number): void;
    applyForceZ(value: number): void;
    applyCentralForce(x: number, y: number, z: number): void;
    applyCentralImpulse(x: number, y: number, z: number): void;
    applyCentralLocalForce(x: number, y: number, z: number): void;
    applyImpulse(impulse: XYZ, relativePosition: XYZ): void;
    applyLocalTorque(x: number, y: number, z: number): void;
    applyTorque(x: number, y: number, z: number): void;
    applyTorqueImpulse(x: number, y: number, z: number): void;
    /**
     * Add the collision flags
     * @param value 0 is DYNAMIC, 1 is STATIC, 2 is KINEMATIC, 4 GHOST
     */
    setCollisionFlags(value: number): void;
    /**
     * Get the collision flags
     * @param value 0 is DYNAMIC, 1 is STATIC, 2 is KINEMATIC, 4 GHOST
     */
    getCollisionFlags(): number;
    /**
     * Set the restitution (same as bounciness)
     * @param value A number from 0 to 1.
     */
    setRestitution(value: number): void;
    /**
     * Set the bounciness (same as restitution)
     * @param value A number from 0 to 1.
     */
    setBounciness(value: number): void;
    /**
     * Set the friction
     * @param value A number from 0 to 1.
     */
    setFriction(value: number): void;
    /**
     * Set the linear and angular damping
     * @param linear A number from 0 to 1.
     * @param angular A number from 0 to 1.
     */
    setDamping(linear: number, angular: number): void;
    /** Set per body gravity */
    setGravity(x: number, y: number, z: number): void;
    setLinearFactor(x: number, y: number, z: number): void;
    setAngularFactor(x: number, y: number, z: number): void;
    setCcdMotionThreshold(threshold: number): void;
    setCcdSweptSphereRadius(radius: number): void;
}
export default PhysicsBody;
//# sourceMappingURL=physicsBody.d.ts.map